<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Lambda-lite-js | 微型函数式语言 by icymorn</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/tomorrow.css">
    <link rel="stylesheet" href="stylesheets/console.css">
    <script src="javascripts/highlight.pack.js"></script>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/ll.min.js"></script>
</head>
<body>
<div id="wrap">
    <div id="head">
        <h1>Lambda-lite-js | 微型函数式语言</h1>
        <h2>a tiny FUNCITONAL LANGUAGE. <a href="https://github.com/icymorn/lambda-lite-js">star me</a></h2>
    </div>
    <div id="description">
        <h3>Introduction | 介绍</h3>

        <div class="detail">
            <p>ll.js 是一个由 javascript 实现的函数式语言，任何开启 javascript 支持的浏览器都可以运行它。函数式编程可以用另一种优雅的方式，（通常）用更少的代码获得同样的结果，由于函数式的直观和简短，通常我们的代码出错的概率会更少。目前 ll 语言其支持以下特性：</p>
            <p><ul>
                <li>lambda 函数定义</li>
                <li>函数柯里化, lazy-evaluation, 匿名递归（利用 z-combinator）</li>
                <li>模式匹配</li>
                <li>Point-free 风格编程</li>
                <li>数字，字符串，布尔型计算，以及 +-*/ 中缀操作符的支持</li>
                <li>if ... else ... 判断分支</li>
            </ul></p>
<!--<pre><code class="haskell">-&#45;&#45; 示例：阶乘 -&#45;&#45;-->
<!--let fact = \n ->-->
    <!--if n == 1 then 1 else n * (fact n - 1);-->
<!--print (fact 5);-->
<!--</code></pre>-->

<textarea id="source">let fact = \n ->
    if n == 1 then 1 else n * (fact n - 1);
print (fact 5);</textarea>
<button id="run">Run</button>
<div id="console">
</div>
        </div><a class="btn" href="https://github.com/icymorn/lambda-lite-js/zipball/master">.ZIP file</a><a class="btn" href="https://github.com/icymorn/lambda-lite-js/tarball/master">.TAR file</a><a class="btn" href="https://github.com/icymorn/lambda-lite-js">Github</a>
    <h3>Usage | 使用方法</h3>

        <div class="detail">
            <b>Lambda function | 匿名函数</b>
            <p>lambda 函数是只带有一个参数的匿名函数，它们的组合和排列能演绎出复杂的效果。声明函数通过反斜杠引出，具体见下：</p>
<pre><code class="haskell">--- 函数声明 ---
\n -> n + 1;
\n -> n * n;
\n -> n + n * n;
</code></pre>
            <p>通过函数之间的组合，可以巧妙实现多参数的函数。</p>
<pre><code class="haskell">--- 两参数函数 ---
(\n -> \m -> m + n) 1 2 --- output: 3
</code></pre>
            <br />
            <b>Various declaration | 变量声明</b>
            <p>使用 let 关键字声明变量：</p>
<pre><code class="haskell">--- 变量声明 ---
let x = 5;
let y = \n -> n + 1;
let z = true;
let p = "hello world";
</code></pre>
            <p>通过语法糖，声明一个多参数的函数更加简单快捷了。</p>
<pre><code class="haskell">---多参数函数 ---
let add x y = x + y
let result = add 1 2
</code></pre>
            <br />
            <b>Native function | 原生函数</b>
            <p>目前内置了一些原始操作符和原生函数，唯有的几个中缀函数让编写表达式计算更加方便：</p>
<pre><code class="haskell">--- 原生函数 ---
print "hello world";
print 1 > 2;
print 3 == 3;
print 4 + 6 * 5;
</code></pre>
            
            <br />
            <b>Point-Free Style</b>
            <p>通过 $ 和 . 的运用，可以写出优美直观，符合 Point-Free Style 的程序。</p>
            
<pre><code class="haskell">--- 计算 (10 + 10) ^ 2 ---
let double = \n -> n + n;
let square = \n -> n * n;
print $ double $ square 10; --- output: 200 ---
let func = double . square;
print $ func 10;            --- output: 200 ---
</code></pre>
            
        </div>

        <br />
        <b>Pattern matching | 模式匹配</b>
        <p>对同一个函数使用不同的参数, 可以自动匹配出不同的处理,可以使用类型来匹配（Boolean, List, Number, String）,也可以使用具体的值.</p>
<pre><code class="haskell">--- 类型匹配 ---
let echo a@Number = print 'Number';
let echo a@String = print 'String';

echo 'this is string';
</code></pre>
        <p>可以将值匹配和类型匹配混合用</p>
<pre><code class="haskell">--- 值匹配 ---
let echo a@1 = print 'Number 1';
let echo a@Number = print 'Other number';
let echo a@* = print 'Other type';

echo 1;
</code></pre>

        <p>使用模式匹配需要注意的是, 同名函数的参数长度必须相同, 每个参数的描述都要用 @ 隔开并且有描述符. 同名函数的参数顺序和名字要一样.</p>
<pre><code class="haskell">--- 模式匹配在阶乘中 ---
let fact n@1 = 1;
let fact n@Number = n * (fact n - 1);
print $ fact 5;
</code></pre>
        <br />


        <footer>
          Project maintained by <a href="https://github.com/icymorn">icymorn</a>
        </footer>
</body>
<script>hljs.initHighlightingOnLoad();</script>
<script>
    var source = document.querySelector('#source');
    var run = document.querySelector('#run');
    var output = document.querySelector("#console");
    var Node = ll.require('./node').Node;
    var print = new Node.lambdaNode('$1', new Node.nativeFunction(function(scope) {
        var e = document.createElement('div');
        e.innerHTML = '> ' + scope.lookup('$1').getValue(scope);
        output.appendChild(e);
    }));
    run.addEventListener('click', function() {
        var parser = ll.require('./lex').parse;
        var genTree = ll.require('./lex').genTree;
        var root = ll.require('./scope').Root;
        var Scope = ll.require('./scope').Scope;
        var scope = new Scope(root);
        scope.add('print', print);
        parser(source.value);
        var statements = genTree();
        statements.forEach(function(e) {
            e.getValue(scope);
        });
    });
</script>
</html>
